### 各种框架响应式的历程

2009 年 AngularJS 和 Node.js 的诞生，前端 MVVM 模式

前端三大框架，在前端 MVVM 模式下，不同框架的目标都是一致的，就是利用数据驱动页面；**核心问题就是，数据发生变化后，我们怎么去通知页面更新。**

* **Angular 1 ：**最老套的脏检查。即每次用户交互时都检查一次数据是否变化，有变化就去更新 DOM 这一方法。这个方法看似简单粗暴，但算是数据驱动页面早期的实现，所以一经推出，就迅速占领了 MVVM 市场。

* **Vue 1： **使用响应式，初始化的时候，Watcher 监听了数据的每个属性，这样数据发生变化的时候，我们就能精确地知道数据的哪个 key 变了，去针对性修改对应的 DOM 即可，这一过程可以按如下方式解构：

![image-20220914141536134](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220914141536134.png)

左边是实际的网页内容，我们在网页中使用 **{{}}** 渲染一个变量，Vue 1 就会在内容里保存一个监听器监控这个变量（框架自己的响应逻辑，不是自己加），我们称之为 Watcher，数据有变化，watcher 会收到通知去更新网页。

* **React：**虚拟 DOM；**在页面初始化的时候**，在浏览器 DOM 之上，搞了一个叫**虚拟 DOM **的东西，也就是**用一个 JavaScript 对象来描述整个 DOM 树**。可以很方便的通过虚拟 DOM 计算出变化的数据，去进行精确的修改。

![image-20220914142007548](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220914142007548.png)

在 React 中，这样一段 HTML 会被映射成一个 JavaScript 的对象进行描述。**这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。**

虚拟 DOM 在运行的时候就是这么一个对象：

![image-20220914142138988](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220914142138988.png)

这个对象完整地描述了 DOM 的树形结构，**当数据有变化的时候，我们生成一份新的虚拟 DOM 数据，然后再对之前的虚拟 DOM 进行计算，算出需要修改的 DOM，再去页面进行操作。**浏览器操作 DOM 一直都是性能杀手，而虚拟 DOM 的 Diff 的逻辑，又能够确保尽可能少的操作 DOM，这也是虚拟 DOM 驱动的框架性能一直比较优秀的原因之一。

![image-20220914142400720](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220914142400720.png)



<hr>

在这个版本时代中：在 Vue1 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而 React 的数据变化后，我们只能通过新老数据的计算 Diff 来得知数据的变化。

缺点：

* 对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。即所有需要响应式的数据，都要有新建 Watcher 监听，本身就比较损耗性能，项目大了之后**每个数据都有一个 watcher 会影响性能。**

* React 的虚拟 DOM 的 Diff 计算逻辑来说，如果虚拟 DOM 树过于庞大，使得计算时间大于 16.6ms，那么就可能会造成性能的卡顿。**（React之后的版本借鉴了操作系统时间分片的概念，把整个虚拟 DOM 树微观化，变成链表，然后我们利用浏览器的空闲时间计算 Diff。一旦浏览器有需求，我们可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲。这种架构虽然没有减少运算量，但是巧妙地利用空闲实现计算，解决了卡顿的问题。）**



#### 重点是Vue2的做法：

Vue 1 的问题在于响应式数据过多的话，会匹配相应数量的watcher监听，带来内存占用过多的问题。所以 Vue 2 大胆引入虚拟 DOM 来解决响应式数据过多的问题。

**Vue1的响应式数据是主动推送变化，React虚拟 DOM 是被动计算数据的 Diff，一个推一个拉，它们看起来是两个方向的技术，但被 Vue 2 很好地融合在一起，采用的方式就是组件级别的划分。**

**对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟 DOM 去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟 DOM 的量级，也控制在了组件的大小。**

eg：下图左边就是一个个的组件，**组件内部是没有 Watcher 监听器的，而是通过虚拟 DOM 来更新；每个组件对应一个监听器，大大减小了监听器的数量。**

![image-20220914143531528](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220914143531528.png)

这个解决方案使用虚拟 DOM 解决了响应式数据过多的内存占用问题，又良好地规避了 React 中虚拟 DOM 的问题， 还通过虚拟 DOM 给 Vue 带来了跨端的能力。



想要用好 Vue，首先就是专注数据本身的操作。

<hr>

Vue 3 很优秀的一个点，就是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到了按需更新，很好的提高了性能。具体后续学习。