### 前端路由历史由来

在 jQuery 时代，对于大部分 Web 项目而言，前端都是不能控制路由的，而是需要依赖后端项目的路由系统。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220927102557880.png" alt="image-20220927102557880" style="zoom:67%;" />

那个时代的前端工程师，都要学会在后端的模板，比如 JSP，Smatry 等里面写一些代码。但是在这个时代，前端工程师并不需要了解路由的概念。对于每次的页面跳转，都由后端开发人员来负责重新渲染模板。

前端依赖后端，并且前端不需要负责路由的这种开发方式，有很多的优点，比如开发速度会很快、后端也可以承担部分前端任务等，所以到现在还有很多公司的内部管理系统是这样的架构。当然，这种开发方式也有很多缺点，比如前后端项目无法分离、**页面跳转由于需要重新刷新整个页面**、等待时间较长等等，所以也会让交互体验下降。

为了提高页面的交互体验，项目的结构也发生了变化。下图所示的，是在目前的前端开发中，用户访问页面后代码执行的过程。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220927102728964.png" alt="image-20220927102728964" style="zoom:67%;" />

我的理解：**之前是每次跳转都要去后端请求匹配路由模板，现在是前端项目中有了路由，打包后的dist文件中的index.html即为入口，然后路由也都在这个项目中，不需要再去请求后端，也就页面跳转不需要重新刷新整个页面，而是匹配好的动态更新到这个入口**

***用户访问路由后，无论是什么 URL 地址，都直接渲染一个前端的入口文件 index.html，然后就会在 index.html 文件中加载 JS 和 CSS。之后，JavaScript 获取当前的页面地址，以及当前路由匹配的组件，再去动态渲染当前页面即可。用户在页面上进行点击操作时，也不需要刷新页面，而是直接通过 JS 重新计算出匹配的路由渲染即可。***

通过 JavaScript 动态控制数据去提高用户体验的方式并不新奇，Ajax 让数据的获取不需要刷新页面，SPA 应用让路由跳转也不需要刷新页面。这种开发的模式在 jQuery 时代就出来了，浏览器路由的变化可以通过 pushState 来操作，这种纯前端开发应用的方式，以前称之为 Pjax （pushState+ Ajax）。之后，这种开发模式在 MVVM 框架的时代大放异彩，现在大部分使用 Vue/React/Angular 的应用都是这种架构。

**SPA 应用相比于模板的开发方式，对前端更加友好，比如：前端对项目的控制权更大了、交互体验也更加丝滑，更重要的是，前端项目终于可以独立出来单独部署了。**

<hr>

### 实现原理

通过 URL 区分路由的机制上，有两种实现方式：

* 一种是 hash 模式，通过 URL 中 # 后面的内容做区分，我们称之为 hash-router
* 另外一个方式就是 history 模式，在这种方式下，路由看起来和正常的 URL 完全一致。

这两个不同的原理，在 vue-router 中对应两个函数，分别是 **createWebHashHistory 和 createWebHistory**。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20220927104357024.png" alt="image-20220927104357024" style="zoom:50%;" />

#### hash模式

单页应用在页面交互、页面跳转上都是无刷新的，这极大地提高了用户访问网页的体验。正是路由放在前端，才实现单页应用

**类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 URL 路径，进行解析，然后动态地渲染出区域 HTML 内容。但是这样存在一个问题，就是 URL 每次变化的时候，都会造成页面的刷新。解决这一问题的思路便是在改变 URL 的情况下，保证页面的不刷新。**

**在 2014 年之前，大家是通过 hash 来实现前端路由。**这就可以用 **hash模式** 来解决

URL hash 中的 # 就是类似于下面代码中的这种 # ：

```
http://www.xxx.com/#/login
```

之后，**在进行页面跳转的操作时，hash 值的变化并不会导致浏览器页面的刷新，只是会触发 hashchange 事件。**

**通过window这个控制整个窗口的“DOM”对 hashchange 事件的监听，就可以在 fn 函数内部进行动态地页面切换。**

```
window.addEventListener('hashchange',fn)
```



#### history模式

2014 年之后，因为 HTML5 标准发布，浏览器多了两个 API：pushState 和 replaceState。通过这两个 API ，可以实现改变 URL 地址，并且浏览器不会向后端发送请求，所以实现前端路由多了另外一种方式：**history模式**

监听了 **popstate** 事件，可以监听到通过 pushState 修改路由的变化。并且在 fn 函数中，实现了页面的更新操作。

```
window.addEventListener('popstate', fn)
```



<hr>

#### 实现一个迷你玩具版vue-router

之后在搞吖！

会用能开发先吖！

<hr>

### 介绍一下 vue-router 在实战中的几个常见功能。

##### （1）动态路由匹配

首先是在路由匹配的语法上，vue-router 支持动态路由。例如有一个用户页面，这个页面使用的是 User 组件，但是每个用户的信息都不一样，**会导致URL也不一样；而路由展示页面本来就是**，需要给每一个用户配置单独的路由入口，这时就可以按下面代码中的样式来配置路由。

```
const routes = [
  { path: '/users/:id', component: User },
]
```

冒号开头的 id 就是路由的动态部分，会同时匹配 /user/xxx 和 /user/yyy

更多路由的匹配语法：[路由的匹配语法 | Vue Router (vuejs.org)](https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html)

##### （2）导航守卫

大多项目都有权限，eg：校园管理系统有 导员，学生，班长...等

这时就需要用到 **vue-router 的导航守卫功能**了，也就是**在访问路由页面之前进行权限认证，这样可以做到对页面的控制，也就是只允许某些用户可以访问。**

##### （3）可以首屏加载优化

项目庞大之后，如果首屏加载文件太大，那么就可能会影响到性能。

可以使用 vue-router 的动态导入功能，把不常用的路由组件单独打包，当访问到这个路由的时候再进行加载，这也是 vue 项目中常见的优化方式。

<hr>

**心得：（感觉，有点像微信小程序的分包加载？原来vue和小程序一样（或者说小程序学vue），发布的时候把整个项目都打包了，用户第一次打开，就是加载了整个程序SPA，已经包含了所有页面，所以路由可以放在前端跳转直接匹配即可，不用再去后端请求匹配；正是因为用户第一次打开加载整个程序，所以会比较慢，所以有了首屏加载的问题，所以优化首屏加载防止用户首次打开加载太久，因此小程序有了分包加载，vue-router 的动态导入；以及其他更多的首屏优化方式）**

<hr>

关于 vue-router 实战中的种种优化和注意点，在课程后续的 15-19 讲，也就是实战痛点中，会借助实战场景，挨个学习，这里就不用了。

<hr>

优秀讨论：

1、什么是路由

所谓 router 是干什么的？是指 route 的，这里中文翻译的是 “路”。何为“路由”，可能是“路由哪里    来"；这里的“路”，广义上来说是“资源”，可以是“页面”，也可以是 json 音视频等等。

如果把路由具象化，它是这么个东西；你告诉它一串神秘的代码（地址，url等），它给你“宝贵的资   源”，它就是个“指路的”。

路由是“天然”存在的，因为我们所有在网上的行为本质都是向“某个地方”要“某些资源”  

2、前后端路由的区别的补充

传统方式与SPA“页面跳转”的问题涉及一个核心的问题，是“导航流程”，具体可以参考，李兵老师《浏览器工作原理与实践》中导航流程一节。

导航流程简单说，就是浏览器地址栏输入地址后，到浏览器准备渲染页面前这个阶段。开始流程的一个标志，就是浏览器标签页标题左边开始转圈圈。传统的开发模式写出的页面，在每一次请求网络资源的过程，理论上都有这个流程。这可能就是两者之间性能差异所在而 SPA 开发模式，网络资源用 XMLHttpRequest 调用，页面部分用JS“模拟”页面刷新。这里JS模拟部分就是现在所学 vue-router 的工作。 



3、关于路由实现

总结下，时间以2014年，HTML5标准作为分野，分两个部分

– API：location.hash；Event：hashchange

– API：history.pushState，history.replaceState；Event：popstate

这个就是前端路由的实现核心，如果对具体API感兴趣，可以参考《Javascript 高级程序设计》第4    版，12章，关于 BOM 的描述。

大致意思是 hash 的改变不触发页面 reloads；pushState，replaceState 改变 history 也不触发    reloads。浏览器的这种行为，是根据 HTML5 这个标准实现的     然后，第一个API支持了路由的 hash 模式，在这之前 hash 的应用 <a id="xxx"> 在页面中的定位，第二个API支持了路由的 history 模式，但这个需要后端配合调整下后端路由；为什么，试着将要跳转的地址复制到浏览器地址栏，然后按回车，分析下页面渲染的过程，大概就清楚了。